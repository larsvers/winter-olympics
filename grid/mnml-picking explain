1. Making a grid with d3 and Canvas
2. Adding interactivity
3. Add an arrow tooltip


1. Making a grid with d3 and Canvas

I have a simple container div.

I add some data, let's say 5000 values. We get this easily with d3.range(5000), which returns an array of 5000 values from 0 to 4999.

Then let's add the container with d3 as in 

var canvas = d3.select('#container')
	.append('canvas')
	.attr('width', width)
	.attr('height', height);


We now have our canvas in our container. But we haven't got any tools to draw with, we haven't got our 'context' yet you would create with:

var context = canvas.node().getContext('2d')

However, let's wait a litlle with it until we actually draw something. The next step doesn't involve drawing yet - it involves preparing all our elements we want to draw. The main reason why we want to prepare first before we draw is to get a good conecptual model of all the elements we want to draw. It's a bit like building some LEGO. We can rip open the box and start building something or we look at the manual first and build it according to this blueprint. The manual is our mental model of what we want to build.

The other reason why we would like to have a model, is that we will use a model that has already been sketched out for us: we will use D3's model. What is D3's model? Apart from the large number of enormeously helpful functions and methods that calculate positions, re-shape datasets (the layouts) and generate functions that draw for example paths for us, D3 has a model for how the elements' lives should evolve on the screen. It has a certain way to think about the lifecycle of each element. Less etherally, we inject data into a yet non-existent DOM, D3 then creates new elements - usually one per datapoint. After injecting new data into the DOM it identifies which elements have to be newly created, which elements are allowed to stay and which elements should pack in and leave the screen. We can firmly grab these elements with D3's selections and do with them whatever we want. 

We usually use D3 in conjunction with SVG or sometimes with HTML. In this orthodox case, we can see the data in the DOM when we choose to look at it through the console or the like. We can grab it, we can move it up or down the DOM and we can - importantly - add interactivity to each element we like to show for example a tooltip. But - on the downside - we can't show a lot of elements. Why? Becuase the more elements we push into the DOM, the harder our Browser has to work to display them all. Let them also move around and the Browser needs to re-calculate them constantly. The more knackered our Browser gets the lower our frame rate or FPS (Frames Per Second), wich is a measure describing how many frames the Browser can paint each second. A frame rate of 60 is good and enables a fluid experience - a frame rate of anything under 25 equals a choppy ride. So when we want to show more elements, we can revert to canvas. 

Why canvas? Canvas is an HTML5 element which comes with its own API to paint on it. All elements drawn on the canvas element won't manifest in the DOM and save a lot of work for the Browser. They are drawn in immediate mode (https://en.wikipedia.org/wiki/Immediate_mode_(computer_graphics)), meaning the rendered elements won't get saved in something like the DOM but our instructions directly draw them to a particular frame. The DOM only knows the one canvas element, everyting on it is only in memory. If we want to change them we have to redraw the scene for the next frame.

The problem with this is of course that we can't communicate directly with these elements but have to find a way to talk to them indirectly. This is where our D3 model comes in and something we could call a virtual DOM (similar in concept but not to confuse with the virtual DOM in React). What we'll do in prinicpal is: 

(1) Bind our data to custom DOM elements that don't live in the DOM but only in memory (in a 'virtual' DOM) and describe the life-cycle of these elements in a known D3 way 
(2) Use canvas to draw these elements
(3) Add interactivity with a technique called 'picking'

But what will we actually build?

In the first steo we will build this: link

A grid of squares of anything up to 10000 squares (so that it pays out to use canvas). We'll give the little squares some colour and give the user the option to update the number of squares. 

The second step then adds some simple interactivity to it. The user can hover over each square and will get back its index. Thrilling stuff !

#The HTML

...is simple

The main HTML structure of our site will be:


	<h3>Coloured grids</h3> A title

	<input type="text" id="textinput" value="10000"> An input field with a default value

	<div class="explain" id="text-explain">...takes numbers between 1 and 100k</div> An explanation

	<div id="container"></div> and a container for our canvas element



The Javascript structure is really straight forward in a top level. 


// makeChart is our main function that keeps all our actions

makeChart(data) {
	
	databind(data) {

		// bind data to custome elements

	}

	draw() {

		// draw the elements on the canvas

	}

	// and eventually here we set off the drawing of the canvas whenever we change the data

}



(1) Bind the elements

To bind the elements we first create a base element for all our custom elements we will produce and draw. If you know D3 well, think of it as a replacment to our svg element:


	function makeChart(data) {

		// === Bind data to custom elements === //

		var customBase = document.createElement('custom');
		var custom = d3.select(customBase); // this is our svg replacement




Then we add some settings for our grid. In short these settings allow us to draw a grid squares which are packed together in square collections or 'parcels' of 100 and a break a line after 10 parcels (so after 1000 squares). You can adjust this for different 'parcelling' of the squares or different line-breaking, or just not worry about it. I suggest the latter...  

		// settings for a grid with 40 cells in a row and 2x5 cells in a group
		var groupSpacing = 4;
		var cellSpacing = 2;
		var offsetTop = height / 5;
		var cellSize = Math.floor((width - 11 * groupSpacing) / 100) - cellSpacing;



Now let's bind the data to our custom elements ! 


		// === Bind and draw functions === //


		function databind(data) {

			numberScale = d3.scaleSequential(d3.interpolateSpectral).domain(d3.extent(data, function(d) { return d; })); // get a scale for the colours working - not essential but nice


Here we join the data to our 'replacement-svg' we called custom above and add yet non-existing custom elements with the class 'rect'

			var join = custom.selectAll('custom.rect')
				.data(data);

We enter the custom elements (remember nothing enters the DOM, this is all in memory)

			var enterSel = join.enter()
				.append('custom')
				.attr('class', 'rect')
	      .attr("x", function(i) {
	        var x0 = Math.floor(i / 100) % 10, x1 = Math.floor(i % 10);
	        return groupSpacing * x0 + (cellSpacing + cellSize) * (x1 + x0 * 10);
	      })
	      .attr("y", function(i) {
	        var y0 = Math.floor(i / 1000), y1 = Math.floor(i % 100 / 10);
	        return groupSpacing * y0 + (cellSpacing + cellSize) * (y1 + y0 * 10);
	      })
				.attr('width', 0)
				.attr('height', 0);

we merge the enter selection into our update selection and define all attributes for th update and enter selection:

			join
				.merge(enterSel)
				.transition()
				.attr('width', cellSize)
				.attr('height', cellSize)
				.attr('fillStyle', function(d) { return numberScale(d); });

Now, please note this last line. 2 things of note when coming from D3. When we work with SVG this line would be 

				.style('color', function(d) { return numberScale(d); })

But with canvas we use .attr(). Why? Because we won't access the CSS style properties of the SVG element - which is what the D3 .style() function does, but we just want to attach the colour information to our custom element. We want to use the element simply to transport our data about which colour to use for this particular element. We attach this data best to the element via the .attr() method. Also we don't say 'color' as attribute property but 'fillStyle'. To be honest, we could use 'chooChooTrain' here, we would only need to remember this when we download the information later during drawing. As canvas uses 'fillStyle' to style elements, it seems more appropriate in this case. You might think differently...

Eventually we also define the exit selection, deciding what should happen to exiting elements.



			var exitSel = join.exit()
				.transition()
				.attr('width', 0)
				.attr('height', 0)
				.remove();

That's it ! We can close our databind() function and move on...

		} // databind()


This is not really scary coming from D3 as it's pretty much exactly the same. We have now succesfully created our data model, the way the application will think about our data. Each element will get the properties it needs to be drawn via the .attr() functions and each element will be assigned a life-cycle state depending on the injected data. Our standard D3 model.

Now we need to write the draw function to get the elements on screen. Let's just note here that nothing has happened yet - we haven't called databind() yet because we need to find a way to draw it to the canvas first. So here we go... The draw function doesn't need to take any arguments in our case:


		// === Draw canvas === //

		function draw() {


As mentioning above fleetingly, we need to take care of cleaning the canvas every time we draw afresh. The DOM is material, in that when I draw a rect element on it and I change it's x value, it will move in the x-direction and the DOM will take care of this move (or the -re-paint) automatically. If we move a rect from x = 0 to x = 1 at a certain point in time (after a button press for example) the browser will move the rect from 0 to 1 within one tick or frame-paint (which is  roughly 16ms long). If you move it from 0 to 10, it will do so in a time depending on the duration you asked this transition to happen, maybe 1 pixel per tick maybe 8 pixel per tick (for more read: https://www.html5rocks.com/en/tutorials/speed/unnecessary-paints/). But it will tell the pixel at 0 that the rect has disappeared and the pixel at 1 that there is a rect now. Canvas doesn't do this. We need to tell canvas what to paint, and if we paint something new, we need to tell it to remove the previous paint. So here's how we clean it: 

			// clear canvas
			
			context.fillStyle = '#fff';
			context.fillRect(0, 0, width, height);


Simple.

Now we (1) get hold of all elements in order to (2) loop through all elements and (3) take the information we have stored in the databinding() function to draw the element.
			
			// draw each individual custom element with their properties
			
			var elements = custom.selectAll('custom.rect') // this is the same as the join variable, but used here to draw
			
			elements.each(function(d,i) {

				// for each virtual/custom element...

				var node = d3.select(this); // this is each individual element in the loop

				context.fillStyle = node.attr('fillStyle'); // here we apply the colour

				context.fillRect(node.attr('x'), node.attr('y'), node.attr('width'), node.attr('height')) // and here we draw the square

			}); // loop through each element

And that's it ! We can close the draw() function


		} // draw()


All rather straight forward, no?

However, we haven't done anything yet. We have the tools in the databind() and the draw() function but we haven't drawn in yet. How do we do this? If we just wanted to draw a static visual or image, we would just call 

		databind(data)
		draw()

This would bind the data to the custom elements which would live in memory and then draw it - once ! 

But we have transitions. Remember above when we wrote our update function we transition the cell width and height from 0 to their size as well as the colour from black to the respective element's colour. A D3 transition lasts 250 ms, so we need to redraw the our squares many times in these 250ms in order to get a smooth transition. How do we do this? It's again simple. We just call databind(data) to create our custom elements before we repeatedly call draw(). We could use setInterval() for this but we really should use requestAnimationFrame() in order to be as performant as possible (for more: https://css-tricks.com/using-requestanimationframe/). Now luckily we can use requestAnimationFrame() by just using d3.timer() which runs it in the background. So here we go:


		// === First call === //

		databind(d3.range(value)); // Build the custom elements in memory
		
		var t = d3.timer(function(elapsed) {
			draw();
			if (elapsed > 500) t.stop();
		}); // start a timer that runs the draw function for 500 ms (or anything slightly higher than the transition time for our custom elements)

d3.timer calls the callback repeatedly until elapsed (which is the passed time in milliseconds) is past 500 and then teh timer is stopped. In these 500 milliseconds, it runs the draw at each tick (roughly each 16ms). draw() then looks at each element's attributes and draws them accordingly. Note that draw needs to come right after the databind() function. So we couldn't ask the machine to run databind() then do something else for a second and then draw. Becasue after a second the transitioned states databind calculates have all been done and dusted. 

That's it ! We've bound data to custom elements and we've drawn it to the canvas.


In order to give the user the chance to repeat this feat with a custom number of elements (ok, semi-custom with a maximum of 100k) we add the following listener and handler to our textinput box:



		// === Listeners/handlers === //


		d3.select('#textinput').on('keydown', function() {

			if (d3.event.keyCode === 13) { // Only do something if the user hits return (keycode 13)

				if (+this.value < 1 || +this.value > 100000) { // if the user goes lower than 1 or higher than 100k

					d3.select('#text-explain').classed('alert', true); // ... highlight the note about the range

					return;

				} else { // if the user types in a sensible number

					d3.select('#text-explain').classed('alert', false); // remove potential alert colours from the note

					value = +this.value; // set the value

			    databind(d3.range(value), colourId); // bind the data 

					var t = d3.timer(function(elapsed) {
						draw();
						if (elapsed > 500) t.stop();
					}); // start a timer that runs the draw function for 500 ms (this needs to be higher than the transition in the databind function)

				}
		  
		  } // keyCode 13 === return
		  
		}); // text input listener/handler


	} // makeChart()


